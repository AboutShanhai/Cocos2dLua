--------------------------------------------------cc.Director Start--------------------------------------------------
--场景切换
cc.Director:getInstance():replaceScene(NewScene)

--获取当前场景
local lRunningScene = cc.Director:getInstance():getRunningScene()

--表示获得窗口(可视区域)的大小
local lWinSize = cc.Director:getInstance():getVisibleSize()

--[[
--获取当前运行的场景
CCScene * getRunningScene (void) 

--获取当前的FPS
double getAnimationInterval (void)

--设置FPS
virtual void setAnimationInterval (double dValue)=0 

--是否在屏幕底部显示FPS
bool isDisplayFPS (void) 

--设置在屏幕底部显示FPS
void setDisplayFPS (bool bDisplayFPS)

--获取CCEGLView
CC_GLVIEW * getOpenGLView (void)

--设置CCEGLView
void setOpenGLView (CC_GLVIEW *pobOpenGLView)

--当然是否适合暂停
bool isPaused (void) 

--获取从director开始起，所有被调用的Frames的数量
unsigned int getFrames (void) 

--获取OpenGl的projection
ccDirectorProjection getProjection (void) 

--设置Opengl 的projection
void setProjection (ccDirectorProjection kProjection) 

--场景替换时，是否接收到cleanup时间，若新的的场景是被push进来的，旧的场景不会收到cleanup 事件，若新的场景是被替换进来的，旧的场景就能够收到cleanup事件。
bool isSendCleanupToScene (void) 

CCSize getWinSize (void) --获取Open gl view的大小，单位为点

--表示获得窗口(可视区域)的大小，如果DesignResolutionSize跟屏幕尺寸一样大，则getVisibleSize等于getWinSize。
--getVisibleOrigin：表示可视区域的起点坐标，这在处理相对位置的时候非常有用，确保节点在不同分辨率下的位置一致。
CCSize getVisibleSize (void) 

-- 获取以像素为单位的open gl view大小
CCSize getWinSizeInPixels (void) 

--获取以像素为单位的open gl view 的显示区域大小
CCSize getDisplaySizeInPixels (void) 

--改变projection的大小
void reshapeProjection (const CCSize &newWindowSize) 

--将UIKIT坐标体系转化为opengl坐标体系
CCPoint convertToGL (const CCPoint &obPoint) 

--将opengl坐标体系转化为UIKIT坐标体系
CCPoint convertToUI (const CCPoint &obPoint)

--获取缺省镜头Z的位置
float getZEye (void) 

--运行场景
void runWithScene (CCScene *pScene) 

--push场景
void pushScene (CCScene *pScene) 

--pop场景
void popScene (void)

--实现场景切换
void replaceScene (CCScene *pScene) 

--暂停游戏
void pause (void) 

--回复游戏
void resume (void) 

--停止动画
virtual void stopAnimation (void) = 0 

--开始动画
virtual void startAnimation (void) = 0 

--每次frame都会被调用，无需自己调用
void drawScene (void) 

--删除缓存的数据
void purgeCachedData (void) 

--设置Opengl的默认值
void setGLDefaultValues (void) 

--设置是否启用opengl的alpha通道
void setAlphaBlending (bool bOn) 

--设置是否测试景深
void setDepthTest (bool bOn)

--游戏主循环
virtual void mainLoop (void)=0

--是设备方向设置生效
void applyOrientation (void) 

--获取设备方向
ccDeviceOrientation getDeviceOrientation (void) 

--设置游戏横屏
void setDeviceOrientation (ccDeviceOrientation kDeviceOrientation) 

--设置是否启用视网膜屏支持
bool enableRetinaDisplay (bool enabled) 

--是否启用视网膜屏支持
bool isRetinaDisplay ()

--重置游戏
void resetDirector ()
]]
--------------------------------------------------cc.Director End--------------------------------------------------





--------------------------------------------------cc.FileUtils Start--------------------------------------------------
--路径搜索

--追加搜索路径
cc.FileUtils:getInstance():addSearchPath(path)

--获得所有搜索路径集合，返回值是一个table
cc.FileUtils:getInstance():getSearchPaths()

--设置搜索路径集合
cc.FileUtils:getInstance():setSearchPaths(searchPaths)   

--搜索文件是否存在
cc.FileUtils:getInstance():isFileExist(filename)
--------------------------------------------------cc.FileUtils End--------------------------------------------------

-- 加载csb资源
--方法一
local rootLayer, csbNode = ExternalFun.loadRootCSB("plaza/PlazaLayer.csb", self)
self.m_rootLayer = rootLayer
self.m_csbNode = csbNode

--方法二
local csbNode = cc.CSLoader:createNode("plaza/PlazaLayer.csb")
csbNode:addTo(self)

--获取控件下所有子控件
local child = self.scrollViewBtnGameType:getChildren()
for i, v in ipairs(child) do
  v:setVisible(false)
end

--table表判空
local lTable = {}
if nil == next(lTable) then
  print("lTable为空表")
else
  print("lTable不为空")
end

--获取当前时间
local time = os.date("%Y-%m-%d %H:%M:%S",os.time())
print("当前时间:" .. time)


:removeAllChildren()
:removeFromParent()

--注册定时器时钟
self._ClockFun = cc.Director:getInstance():getScheduler():scheduleScriptFunc(function ()
    --函数体
    --注销时钟
		cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self._ClockFun)
  end, 1.0, false)


--Cocos2dx V3.10 API
https:--docs.cocos2d-x.org/api-ref/cplusplus/V3.10/

控件
一、Button[按钮]
-- 设置按钮
btn = csbNode:getChildByName("btn_set")					--对应csb文件中的控件名
btn = ccui.Button:create()										  			--创建方法1
btn = ccui.Button:create( "img_btn.png","img_btn.png","img_speedword.png" )	--创建方法2
btn:loadTextures("img_btn.png", "img_btn.png", "img_speedword.png", 0) 		--0:从本地获取资源 1:从plist文件中获取 
btn:setTag(TAG_ENUM.BT_SET)								--设置Tag标识值
btn:getTag()											--获取Tag标识值
btn:setName(TAG_ENUM.BT_SET)							--设置Name标识值
btn:getName()											--获取Name标识值
btn:setAnchorPoint(0.5,0.5) 							--设置锚点cc.p(0.5,0.5)
btn:getAnchorPoint()									--获取锚点cc.p()
btn:getAnchorPoint().x  								--获取锚点的横坐标
btn:getAnchorPoint().y  								--获取锚点的纵坐标
btn:setPosition(520,521)								--设置坐标
btn:setPositionX(520)									--设置坐横标
btn:setPositionY(521)									--设置坐纵标
btn:getPosition()										--获取x,y坐标 Lua中:方法一用两变量接收x,y=btn:getPosition()	方法二转换为point_table再来接收 p=cc.p(sprite:getPosition())
btn:setLocalZOrder(5)                                   --设置层级
btn:setVisible(true)									--设置true可视/false不可视
btn:isVisible()											--获取是否可视true可视/false不可视
btn:setScale(2)											--设置缩放2倍
btn:setScaleX(2)										--设置横向缩放2倍
btn:setScaleY(2)										--设置纵向缩放2倍
btn:setRotation(361)									--设置旋转361度
btn:setSkewX(50)										--按X倾斜50
btn:setRotationSkewX(50)								--按X倾斜50
btn:setSkewX(50)										--按Y倾斜50
btn:setRotationSkewY(50)								--按Y倾斜50
btn:setCascadeOpacityEnabled(true)						--启用透明效果
btn:setOpacity(50)										--设置透明度50
btn:setTitleText("设置文本")							 --设置按钮文本
btn:setTitleColor(cc.c3b(0,255,255)) 					--设置按钮文本颜色
btn:setTitleFontSize(28)								--设置按钮文本字号大小
btn:setEnabled(true)									--设置true可点击/false不可点击
btn:setPressedActionEnabled(true)						--按下放大动画
btn:getContentSize()                  --listBgSize.height, listBgSize.width
btn:addTo(csbNode)										--按钮加入csbNode节点上
btn:addTouchEventListener(touchFunC)					--按钮添加监听事件
	a = Text_roomRule:getAutoRenderSize()
	b = Text_roomRule:getContentSize()

--按钮事件监听
local touchFunC = function(ref, tType)
  local tag = ref:getTag()
	print("控件标识值" .. tag)

  if tType == ccui.TouchEventType.began then
    print("按下按钮")
  elseif tType == ccui.TouchEventType.moved then
    print("按下按钮移动")
  elseif tType == ccui.TouchEventType.ended then
    print("放开按钮")
		this:onButtonClickedEvent(tag, ref)
  elseif tType == ccui.TouchEventType.canceled then	--按下不放，移开到此控件位置为取消
    print("取消点击")
  end
end

function PlazaLayer:onButtonClickedEvent( tag, ref )
  if TAG_ENUM.BT_CONFIRM == tag then                 -- 确定
    print("按下确定按钮")
  elseif TAG_ENUM.BT_CANCEL == tag then               -- 取消
    print("按下取消按钮")
  elseif TAG_ENUM.BT_CLOSE == tag then            		  -- 关闭
    print("按下关闭按钮")
	end
end


addTouchEventListener(function(ref, tType)
if tType == ccui.TouchEventType.ended then

-- 进入场景而且过渡动画结束时候触发。
function GameLayer:onEnterTransitionFinish()
  print("")
  self._gameView:RecordLayerCreate()
end



local strNum = "/"..string.formatNumberThousands(result[i].lScore, true, ".") --"/"代表“+”或者“-”，“.”代表逗号
labAtscore = cc.LabelAtlas:create(strNum, strFile, 16, 19, string.byte("."))
  :move(470, 33)
  :setAnchorPoint(cc.p(0, 0.5))
  :setTag(ResultLayer.TAG_SCORE)
  :addTo(self.nodeUser[i])